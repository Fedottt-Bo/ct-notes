Наследование (Inheritance) — один из ключевых принципов объектно-ориентированного программирования, который позволяет создать новые классы на основе существующих. Это способствует повторному использованию кода, расширению функциональности и упрощению сопровождения программного обеспечения.

\subsection{Интерфейсы}
\begin{itemize}
    \item \textbf{Определение} \\
    Интерфейс в \texttt{Java} — это контракт, который определяет набор методов, которые класс должен реализовать. В интерфейсах методы не имеют реализации, а только сигнатуры. Интерфейсы позволяют определить общие функциональные возможности для разных классов, даже если они не связаны друг с другом через классическое наследование.


    \item \textbf{Применение} \\
    Интерфейсы применяются, когда нужно обеспечить некоторый общий функционал для различных классов. Например, в случае, когда классы не связаны иерархией наследования, но имеют общую функциональность. Интерфейсы широко используются в ситуациях, когда необходимо поддерживать полиморфизм.

    Объявление интерфейса:
    \begin{minted}{java}
public interface Drawable {
    void draw();
}
    \end{minted}
    Здесь интерфейс \texttt{Drawable} определяет один метод \texttt{draw()}, который должен быть реализован любым классом, реализующим этот интерфейс.


    \item \textbf{Реализация} \\
    Класс реализует интерфейс с помощью ключевого слова \texttt{implements}, и он может реализовывать сразу несколько интерфейсов. Это позволяет создавать классы с более гибкими и многообразными функциональными возможностями.

    Пример:
    \begin{minted}{java}
public interface Flyable {
    void fly();
}

public interface Swimmable {
    void swim();
}

public class Duck implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("Duck is flying");
    }

    @Override
    public void swim() {
        System.out.println("Duck is swimming");
    }
}
    \end{minted}
    В этом примере класс \texttt{Duck} реализует два интерфейса — \texttt{Flyable} и \texttt{Swimmable}, предоставляя собственные реализации для методов \texttt{fly()} и \texttt{swim()}.


    \item \textbf{Наследование интерфейсов} \\
    Интерфейсы в \texttt{Java} могут наследовать друг друга с помощью ключевого слова \texttt{extends}. При этом один интерфейс может расширять сразу несколько интерфейсов (в отличие от классов, которые могут наследовать только один класс). Это позволяет создавать более сложные иерархии интерфейсов и задавать различные уровни абстракции.

    Пример:
    \begin{minted}{java}
public interface Movable {
    void move();
}

public interface Flyable extends Movable {
    void fly();
}

public interface Swimmable extends Movable {
    void swim();
}
    \end{minted}
    В данном примере интерфейс \texttt{Flyable} расширяет интерфейс \texttt{Movable}, добавляя метод \texttt{fly()}, а интерфейс \texttt{Swimmable также расширяет \texttt{Movable}}, добавляя метод \texttt{swim()}. Таким образом, любой класс, реализующий \texttt{Flyable} или \texttt{Swimmable}, также должен реализовать метод \texttt{move()}, так как это требование было определено в базовом интерфейсе \texttt{Movable}.
\end{itemize}

\subsection{Наследование}
\begin{itemize}
    \item \textbf{Синтаксис} \\
    В \texttt{Java} наследование реализуется с помощью ключевого слова \texttt{extends}. Новый класс, называемый подклассом (или производным), расширяет функциональность существующего класса, называемого суперклассом (или базовым). Подкласс наследует все публичные и защищённые члены суперкласса, но может переопределять методы для предоставления своей реализации.


    \item \textbf{Применение} \\
    Наследование используется для создания иерархии классов, где более общие классы находятся ближе к вершине, а более специфичные — ниже. Это позволяет создавать гибкие и масштабируемые архитектуры программного обеспечения.

    Пример:
    \begin{minted}{java}
class Animal {
    void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog is barking");
    }
}
    \end{minted}
    В данном примере класс \texttt{Dog} наследует класс \texttt{Animal} и получает его метод \texttt{eat()}, а также добавляет свой метод \texttt{bark()}.


    \item \textbf{Модификатор protected} \\
    Модификатор доступа \texttt{protected} предоставляет доступ к членам класса в пределах того же пакета и в подклассах, даже если они находятся в другом пакете. Это полезно при необходимости делиться внутренними деталями реализации с подклассами, но не делать их доступными из других частей программы.
\end{itemize}

\subsection{Пакеты}
\begin{itemize}
    \item \textbf{Синтаксис} \\
    Пакеты — это механизм группировки классов, интерфейсов и других пакетов в логически связанные единицы. Они помогают структурировать код, избегать конфликтов имён и управлять доступом к классам. Для создания пакета используется ключевое слово \texttt{package}.

    Пример объявления пакета:
    \begin{minted}{java}
package com.example.myapp;
    \end{minted}
    Эта строка должна быть первой в файле, чтобы указать, что класс находится в пакете \texttt{com.example.myapp}.


    \item \textbf{Применение} \\
    Пакеты используются для организации кода и предотвращения конфликтов имён, так как классы с одинаковыми именами могут находиться в разных пакетах. Кроме того, пакеты управляют доступом.

    Для использования классов из других пакетов необходимо импортировать их с помощью ключевого слова \texttt{import}:
    \begin{minted}{java}
import com.example.myapp.MyClass;
    \end{minted}
    Также можно использовать \texttt{import com.example.myapp.*;}, чтобы импортировать все классы из пакета.


    \item \textbf{Файл package-info.java} \\
    Файл \texttt{package-info.java} — это специальный файл, который используется для документирования пакетов в \texttt{Java}. Он может содержать аннотации и комментарии, относящиеся ко всему пакету. Этот файл служит для улучшения организации кода и его документирования, помогая лучше понимать назначение пакета.
\end{itemize}

