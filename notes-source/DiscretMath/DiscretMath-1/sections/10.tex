
\subsection{Комбинаторные объекты}
\textbf{Комбинаторные объекты} - объекты, обладающие между собой некоторыми зависимостями.

Мы будем рассматривать \textbf{линейное представление} комбинаторных объектов - их запись в виде строки над некоторым алфавитом(не обязательно конечным).

Мы хотим научиться:
\begin{enumerate}
\item[1.] Считать количество комбинаторных объектов
\item[2.] Уметь перечислять комбинаторные объекты
\item[3.] Нумеровать комбинаторные объекты 
\item[4.] Выдавать по номеру объект, а по объекту номер
\end{enumerate}
\textbf{Лексикографический порядок} - для двух различных строк $A$ и $B$, строка $A$ лексиграфически меньше строки $B$, если:
\begin{enumerate}
    \item[1.] Строка $A$ - префикс строки $B$
    \item[2.] $\exists i < \min(|A|, |B|): \forall j < i : A_j = B_j$ и $A_i \neq B_i$ 
\end{enumerate}
Очевидно, что этих двух условий достаточно, чтобы задать порядок на строчках. Тогда мы можем задать порядок на всех линейных комбинаторных объектах.

\subsection{Вектора фиксированной длины}
\textbf{Вектор фиксированной длины} - это упорядоченный набор из $n$ (возможно повторяющихся) элементов из алфавита $A$. 

Подсчет количества векторов длины $n$ ни для кого не сотавит затруднения - всего их $|A|^n$.

С нумерацией также проблем не возникает. Пусть $k = |A|$. Тогда давайте зададим каждому элементу из множества $A$ свое число от 0 до $k$. Теперь дадим каждому элементу вектора свой коэффицент, который будет равен $k$ в стенени индекса этого элемента в векторе, то есть для первого элемента это будет $k^0$(для удобства все в 0-индексации), для второго $k^1$ и так далее. Теперь перемножим коэффиценты элементов в векторе на числа, обозначающие данный элемент и получим искомое значение. По факту это запись числа в $k$-ичной системе счисления, и доказательство единственности зашифровки и расшифровки аналогичное.

Из способа нумеровать объекты становится очевиден способы выдавать по номеру объект, мы просто смотрим на остаток от номера по модулю $k$ - это и будет первый элемент вектора, теперь поделим номер на $k$ (с округлением вниз) и аналогично получим второй элемент вектора. Так и продолжим наш алгоритм, пока не получим все элементы вектора.

Если у вас уже упорядочены объекты, то вы можете сортировать их лексикографически.

\subsection{Двоичные вектора без двух единиц подряд}
Не стану вдаваться в подробности, потому что это не очень интересный пример, мы его посмотрим и забудем.

Воспользуемся идеей разделяй и влавствуй и отделим последний элемент нашего вектора. Если это 0, то ограничений на оставшийся вектор нет, а если это 1, то мы точно знаем, что предыдущий элемент нашего вектора это 0, а оставшийся на оставшийся вектор не накладывается никаких ограничений. Тогда мы можем вывести реккурентную формулу: $$F(x) = F(x-1)+F(x-2)$$

Пристальным взглядом можно заметить, что это числа Фиббоначи, а значит мы можем посчитать их по формуле, которую спокойно можно загуглить(не беспокойтесь, на экзамене по дм она вам явно не пригодится).

\subsection{Перестановки}
\textbf{Перестановка} - последовательность длины $n$, такая что все числа в ней от 1 до $n$, при этом в нем нет одинаковых, то есть все числа присутствуют. Можно также это делать не с числами, но полученные перестановки будут изоморфны обычным, так что для удобства дальше мы будем работать только с числами.

Количество перестановок длины $n$ равно $n * (n-1)*(n-2)*\dots *2*1 = n!$.

Очевидно, что перестановки можно лексиграфически нумеровать, так и будем делать.

Давайте научимся по номеру перестановки находить ее. Что происходит, если мы удаляем первый элемент перестановки, у нас остается $(n-1)$ элемент в любом порядке, то есть перестановка на $(n-1)$ элемент. Заведем обозначение на кол-во перестановок длины $k$ - $P_k$. Тогда на первой позиции стоит 1, если итоговый номер не превышает $P_{n-1}$. Если же это не так, давайте выкинем все перестановки, начинающиеся с 1, тогда номер искомой уменьшается на $P_{n-1}$. Для перестановок, начинающихся с 2 мы можем сделать аналогичные умозаключения и понять, стоит в начале перестановки 2 или нет. Продолжая такой алгоритм мы поймем, что стоит на первом месте, тогда можно отбросить это число и продолжить алгоритм для второго числа. Получается такой алгоритм:
\begin{enumerate}
    \item [1.] Имея перестановку длины $n$ и номер искомой перестановки $k$ и набор еще не поставленных чисел $a$ в отсортированном порядке, ставим на первой место перестановки $a[k / P_{n - 1}]$.
    \item[2.] Уменьшаем $n$ на 1, $k$ меняем на $k mod P_{n - 1}$, а из массива $a$ выбрасываем поставленное число и, если он у нас еще не пуст - повторяем алгоритм с начала.
\end{enumerate} 

Ну, раз мы умеем по номеру находить перестановку нам не составит труда запустить обраный алгоритм и узнавать номер перестановки по самой перестановке.

\subsection{Размещения}
\textbf{Размещения} - количество способов упорядоченно выбрать $k$ различных чисел из множества мощностью $n$.

Обозначается $A_n^k$ и имеет формулу $A_n^k = \frac{n!}{(n-k)!}$.

\subsection{Сочетания}
\textbf{Сочетания(биномиальный коэффицент)} - количество способов неупорядоченно выбрать $k$ различных чисел из множества мощностью $n$.

Обозначается $C_n^k$ или $\big(_k^n\big)$ и имеет формулу $C_n^k = \frac{n!}{k!(n-k)!}$(доказательство будет чуть ниже).

Возникают проблемы с тем, что сочетания - не линейный объект и для того, чтобы их решить, введем \textbf{канонизацию}.

\textbf{Канонизация} - довольная абстрактный метод, который говорит: если у нас один и тот же объект может представляться несколькими способами, один из них назовем каноническим, и чтобы упорядочить два объекта, упорядочим их канонические виды. В данном случае, как и во большинстве других, каноническим видом сочетания будет перестановка множества, лексиграфически минимальная, среди всех остальных(Станкевич назвал этот порядок возрастающим, но я буду переиспользовать лексиграфический порядок).

Формула как раз доказывается таким образом, мы берем размещения и говорим, при канонизации у нас все перестановки длины $k$ сводятся к одной строке, значит кол-во сочетаний из n по k = (кол-во размещений из n по k)/(кол-во перестанок длины $k$).

Быстро расскажу про школьный способ считать количество сочетаний, мы снова применяем разделяй и влавствуй для какого-то элемента и если он лежит в множестве, то у нас $C_{n-1}^{k-1}$ способов выбрать оставшиеся элементы, а если он не лежит, то $C_{n - 1}^k$ способов. Снова получаем реккуренту: $$C_n^k=C_{n-1}^k+C_{n-1}^{k-1}$$ для которой можно по индукции доказать, что формула верна, но это выглядит непоследовательно и случайно, а делается довольно просто, поэтому это задания я оставлю читателю, как простейшее упражнение на закрепление формулы сочетаний.

\subsection{Код Грея}
\textbf{Код Грея(для двочиных векторов длины $n$)} - перечисления двочиных векторов в таком порядке, что расстояние Хэмминга между двумя соседними векторами равно 1.

Код Грея называют \textbf{циклическим}, если длина Хэмминга между первой и последней строкой также равна 1.

\textbf{Алгоритм построения циклического кода Грея(зеркального) для двоичных векторов} - Пусть мы хотим построить код Грея для двоичных векторов длины $n$. Построим его для двоичных векторов длины $n-1$ и допишем к ним ко всем в начало 0. Теперь снова этот же код Грея для двоичных векторов длины $n-1$, перевернем его(очевидно, что при этом он останется кодом Грея) и допишем ко всем векторам в нем 1 в начало. Теперь я утверждаю, что я если мы объединим два этих набора векторов, то получим код Грея для векторов длины $n$. Понятно, что коды Грея длины $n-1$, к которым мы приписали один и тот же символ, сломаться не могли, значит, если поломка и произошла, то она произошла на одном из стыков, но это тоже невозможно, ведь там различие только в приписанном в начало символе. Для базы $n=1$ любой порядок векторов будет кодом Грея, значит этот алгоритм может построить код Грея для любого $n$.

\subsection{Формула включений-исключений}
Формально, формула включений-исключений говорит: Если мы умеем считать мощность множеств и мощность их пересечений, то мы можем также посчитать мощность их объединений.

\textbf{Формула}: Для семейства множеств $A_1, A_2, \dots, A_n$: $$\left|\bigcup\limits_{i=1}^{n}A_i\right|=\sum\limits_{I\subset \{1, 2,\dots,n\} I \neq \emptyset}(-1)^{|I|+1}\left(\bigcap\limits_{i\in I}A_i\right)$$
\uline{Доказательство}:
\begin{enumerate}
    \item[] $\displaystyle\left|\bigcup\limits_{i=1}^{n}A_i\right|=\left|\bigcup\limits_{i=1}^{n - 1}A_i \cup A_n\right| = \left|\bigcup\limits_{i=1}^{n - 1}A_i\right| + \left|A_n\right| - \left|\bigcup\limits_{i=1}^{n - 1}(A_i\cap A_n)\right|=\\=\sum\limits_{I\subset \{1, 2,\dots,n-1\}}(-1)^{|I|+1}\left(\bigcap\limits_{i\in I}A_i\right)+|A_n|+\sum\limits_{J\subset \{1, 2,\dots,n\}}(-1)^{|J|+2}\left(\bigcap\limits_{i\in J}A_i\cup A_n\right)$
    
    Посмотрим на эту формулу. Первая сумма это сумма по всем множествам, в которых нет $A_n$, вторая - $A_n$, а третья, это в точности все множества, которые содержат $A_n$ и ещё хоть что-то, причем все с выражения с правильным знаком. Тогда это в точности формула, которую мы хотим доказать.
\end{enumerate}
