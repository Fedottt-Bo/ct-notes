\subsection{Программирование по контракту}
Вот у нас есть функция:

\begin{minted}{java}
public class Contracts{
    int magic(int a, int n){
        int r = 1;
        while(n != 0){
            if(n % 2 == 1){
                r *= a;
            }
            n /= 2;
            a *= a;
        }
        return r;
    }
}
\end{minted}

У нас есть предположение, что эта функция делает бинарное возведение в степень. Но мы в этом не уверены. Мы внимательно посмотрели на код и поняли, что вот это и правда возведение в степень. Но в реальности такое понимать довольно сложно. Сегодня мы поднимемся на уровень выше. Мы научимся \uline{доказывать}, что наша программа делает именно то, что она должна на понятном математическом языке.
Мы будем смотреть на программу, как на математический объект. Мы воспользуемся \deff{тройкой Хоара}.

В терминологии Хоара у нас есть:

\begin{itemize}
    \item  $C$ - блок кода со входом и выходом. 
    \item $\{ P \}$ - пред условие - то, что должно выполняться, чтобы исполнить.
    \item $\{ Q\}$ -  пост условие - то, что гарантирует блок $C$ в результате того, что он был исполнен.
\end{itemize}

Возникает вопрос. Какую структуру может иметь промежуточный код?

\thmm{Теорема Бёма - Якопини}

Если есть какой-то блок кода, то его можно переформулировать в следующую конструкции:
\begin{itemize}
    \item последовательное исполнение.
    \item присваивание.
    \item ветвление.
    \item цикл while.
\end{itemize}

Тяжелую концептуальную вещь мы можем преобразовать в такую штучку. А теперь применим к этому тройку Хоара:

\textbf{Последовательное исполнение:} У меня есть 2 подряд идущих блока кода: $\{ P_1 \} C_1 \{ Q_1\}$, $\{ P_2 \} C_2 \{ Q_2\}$. Какое у них будет пред и пост условие? Кто-то скажет, что
Pred: $P_1$ 
Post: $Q_2$

Достаточно ли этого? Нет. Мы не можем гарантировать $P_2$ в таком случае. Чтобы гарантировать это, мы  также хотим, чтобы из $Q_1$ следовало $P_2$.

\textbf{Присваивание:} $x = expr$ - обычное присваивание. Есть пред. условие $P$, что мы можем сказать, про пост условие? Тут не все так тривиально. Если мы хотим пост условие Q, то я должен потребовать в начале $Q[x \rightarrow expr]$. Примеры:


\begin{minipage}[h]{0.3\linewidth}
\begin{minted}{java}
{ a + 1 < b }
x = a + 1
{ x < b }
\end{minted}
\end{minipage}
\hfill 
\begin{minipage}[h]{0.6\linewidth}
\begin{minted}{java}
{ a + 1 < b }
x = a + 1
{ x < b }
\end{minted}
\end{minipage}

То есть такой подход с подстановкой делает то, что от нас требуется.

\textbf{Ветвление:}

\begin{wrapfigure}{l}{0.3\linewidth} 
   \begin{minted}{java}
if(cond) {
 { P1 } C1 { Q1 }
}else{
 { P2 } C2 { Q2 }
}
\end{minted}
\end{wrapfigure}

Давайте подумаем, какое у нас  \uline{пост условие}:\\  Post: Q1 || Q2 - такое решение очень странное так как мы вообще не шарим, что там будет. Как код писать то следующий? Следуюший код будет делать еще ветвление, а зачем нам его еще раз делать?  \\Так что введем Q такую, что $Q1 \rightarrow Q$, $Q_2 \rightarrow Q$. \\ \\ Теперь поговорим про то, что будет в \uline{пред условии}:\\ Нам нужно, чтобы из $P$ \&\&  cond $\rightarrow$ $P1$, а так же $P$ \&\& !cond $\rightarrow$ $P2$.

Такой подход делает то, что от нас требуется:

\textbf{While:} 

\begin{wrapfigure}{l}{0.3\linewidth} 
   \begin{minted}{java}
while(cond){
 { Pi } Ci { Qi } 
}
\end{minted}
\end{wrapfigure}

Посмотрим на самый первый заход в в цикл. \\ 
Заметим, что из $P$ \&\& cond$ \rightarrow Pi$. Пусть $Qi \rightarrow P$ - можем исполнять сколько угодно раз. Теперь посмотрим на пост условие -  $P$ \&\& $!cond$.

Давайте докажем работу функции из начала:
\begin{minted}{java}
// Pred: n >= 0
// Post: R = a ^ n
int power(int a, int n) {
    int r = 1;
    // r' * a' ^ n' = a ^ n
    while (n != 0) {
        // I && n' != 0
        if (n % 2 == 1) {
            // I && n' % 2 = 1
            r *= a; n--;
            // I && n' % 2 = 0
        } else {
            // I && n' % 2 = 0
        }
        // I && n' % 2 = 0
        n /= 2; a *= a;
        // I
    }
    // r' * a' ^ n' = a ^ n && n' = 0
    // => r' = a ^ n
    // => R = r'
    return r;
}
\end{minted}    

\deff{Функции}

Чистые функции

- Результат зависит только от аргументов

- Не имеет побочных эффектов (не меняют ничего снаружи самой себя)

\deff{Предусловие} --- условие, которое должно быть верно на момент вызова. Результат вызова с неверным предусловием не определен.

\deff{Постусловие} --- условие, которое верно на момент возврата. Если постусловие не выполнено, то в программе есть ошибка.

Например:
\begin{minted}{java}
// Pred: x > 0
// Post: R * R = x ^ R >= 0
double sqrt(double x) {
    ...
}
\end{minted}  

\deff{Функции с состоянием}
\begin{minted}{java}
// Состояние
int value = 0;

// Pred: v >= 0
// Post: R = value + v && value' = value + v
int add(int v) {
    return value += v;
}

\end{minted}  

Добавим пред и постусловия на неотрицательность `value`:
\begin{minted}{java}
// Состояние
int value = 0;

// Pred: v >= 0 && value >= 0
// Post: R = value + v && value' = value + v && value >= 0
int add(int v) {
    return value += v;
}
\end{minted}  

Инвариант --- общая часть пред и постусловия. Выполняется всегда. Обозначается как `Inv`.
\begin{minted}{java}
// Inv: value >= 0
int value = 0;

// Pred: v >= 0
// Post: R = value + v && value' = value + v
int add(int v) {
    return value += v;
}
\end{minted}  

Инвариант + предусловие + постусловие функции с состоянием называется *контрактом*.