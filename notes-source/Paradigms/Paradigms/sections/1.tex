
Вот у нас есть функция:

\begin{minted}{java}
public class Contracts{
    int magic(int a, int n){
        int r = 1;
        while(n != 0){
            if(n % 2 == 1){
                r *= a;
            }
            n /= 2;
            a *= a;
        }
        return r;
    }
}
\end{minted}

У нас есть предположение, что эта функция делает бинарное возведение в степень. Но мы в этом не уверены. Мы внимательно посмотрели на код и поняли, что вот это и правда возведение в степень. Но в реальности такое понимать довольно сложно. Сегодня мы поднимемся на уровень выше. Мы научимся \uline{доказывать}, что наша программа делает именно то, что она должна на понятном математическом языке.
Мы будем смотреть на программу, как на математический объект. Мы воспользуемся \deff{тройкой Хоара}.

В терминологии Хоара у нас есть:

\begin{itemize}
    \item  $C$ - блок кода со входом и выходом. 
    \item $\{ P \}$ - пред условие - то, что должно выполняться, чтобы исполнить.
    \item $\{ Q\}$ -  пост условие - то, что гарантирует блок $C$ в результате того, что он был исполнен.
\end{itemize}

Возникает вопрос. Какую структуру может иметь промежуточный код?

\thmm{Теорема Бёма - Якопини}

Если есть какой-то блок кода, то его можно переформулировать в следующую конструкции:
\begin{itemize}
    \item последовательное исполнение.
    \item присваивание.
    \item ветвление.
    \item цикл while.
\end{itemize}

Тяжелую концептуальную вещь мы можем преобразовать в такую штучку. А теперь применим к этому тройку Хоара:

\textbf{Последовательное исполнение:} У меня есть 2 подряд идущих блока кода: $\{ P_1 \} C_1 \{ Q_1\}$, $\{ P_2 \} C_2 \{ Q_2\}$. Какое у них будет пред и пост условие? Кто-то скажет, что
Pred: $P_1$ 
Post: $Q_2$

Достаточно ли этого? Нет. Мы не можем гарантировать $P_2$ в таком случае. Чтобы гарантировать это, мы  также хотим, чтобы из $Q_1$ следовало $P_2$.

\textbf{Присваивание:} $x = expr$ - обычное присваивание. Есть пред. условие $P$, что мы можем сказать, про пост условие? Тут не все так тривиально. Если мы хотим пост условие Q, то я должен потребовать в начале $Q[x \rightarrow expr]$. Примеры:


\begin{minipage}[h]{0.3\linewidth}
\begin{minted}{java}
{ a + 1 < b }
x = a + 1
{ x < b }
\end{minted}
\end{minipage}
\hfill 
\begin{minipage}[h]{0.6\linewidth}
\begin{minted}{java}
{ a + 1 < b }
x = a + 1
{ x < b }
\end{minted}
\end{minipage}

То есть такой подход с подстановкой делает то, что от нас требуется.

\textbf{Ветвление:}

\begin{wrapfigure}{l}{0.3\linewidth} 
   \begin{minted}{java}
if(cond) {
 { P1 } C1 { Q1 }
}else{
 { P2 } C2 { Q2 }
}
\end{minted}
\end{wrapfigure}

Давайте подумаем, какое у нас  \uline{пост условие}:\\  Post: Q1 || Q2 - такое решение очень странное так как мы вообще не шарим, что там будет. Как код писать то следующий? Следуюший код будет делать еще ветвление, а зачем нам его еще раз делать?  \\Так что введем Q такую, что $Q1 \rightarrow Q$, $Q_2 \rightarrow Q$. \\ \\ Теперь поговорим про то, что будет в \uline{пред условии}:\\ Нам нужно, чтобы из $P$ \&\&  cond $\rightarrow$ $P1$, а так же $P$ \&\& !cond $\rightarrow$ $P2$.

Такой подход делает то, что от нас требуется:

\textbf{While:} 

\begin{wrapfigure}{l}{0.3\linewidth} 
   \begin{minted}{java}
while(cond){
 { Pi } Ci { Qi } 
}
\end{minted}
\end{wrapfigure}

Посмотрим на самый первый заход в в цикл. \\ 
Заметим, что из $P$ \&\& cond$ \rightarrow Pi$. Пусть $Qi \rightarrow P$ - можем исполнять сколько угодно раз. Теперь посмотрим на пост условие -  $P$ \&\& $!cond$.
\\\\
Вернемся и докажем, что это возведение в степень:

\begin{minted}{java}
// Pred: n >= 0
public class Contracts{

    int magic(int a, int n){
         // a'^n' == a^n
        int r = 1;
        // Inv: r * a'^n' == a^n
        while(n != 0){
            //Pred: (r*a') * a'^(n') == a^n
            if(n % 2 == 1){
                //(r*a') * a'^(n'-1) == a^n  && (n' -1) % 2 ==0
                r *= a;
                //r * a'^(n'-1) == a^n  && (n' -1) % 2 ==0
                n -= 1;
                // r * a'^n' == a^n && n' % 2 ==0
            } else{
                // P && n' % 2 == 0
            }
            // r * a'^n' == a^n && n'%2 ==0
            n /= 2;
            // r * (a'*a')^n' == a^n
            a *= a;
            //Inv: r * a'^n' == a^n
        }
        return r;
    }
}
//Post: 
\end{minted}

Пара из пред и пост условий функции является \deff{контрактом}.

Пусть у меня есть 2 кода:




\begin{minipage}[h]{0.5\linewidth}
  \begin{minted}{java}
public class Contracts{
    private int value;
    //Pred: true 
    //Post: R = v' && v' = v + x
    int add(int x){
        value += x;
        return value;
    }
}
\end{minted}
\end{minipage}
\hfill 
\begin{minipage}[h]{0.5\linewidth}
\begin{minted}{java}
public class Contracts{
    private int value;
    //Pred: true 
    //Post: R = v' // 2  && v' = v + 2 * x
    int add(int x){
        value += 2 * x;
        return value / 2;
    }
}
\end{minted}
\end{minipage}

Заметим, что они они работают \uline{идентично}.

