# Деревья.

Деревья храним 2-умя образами:

- Храним родителей.
- Храним детей.

## LCA

LCA(u,v) - Lowest Common Ancestor - это узел w, который является предком и u, и v, и находится на максимальной глубине в дереве. Другими словами, w находится ближе всего к u и v среди всех общих предков.

### Более простая задача.

Давайте решим сначала более простую задачу. Я хочу понимать является ли u предком v. 

У этого есть очевидное тупое решение, но мы люди не тупые => пишем умное. 

Для этого запустим dfs из корня и для каждой вершины будем хранить время входа в вершину и время выхода.

![easy-lca](./assets/10-easy-LCA.png)

Ура, мы теперь умеем решать задачу LCA за линию. Будем поднимать одну вершину наверх, пока не выполнится описанное выше условие.

## Двоичные подъемы.

 Двоичное поднятие (подъемы) (Binary Lifting) (O(log n) времени на запрос):

 Концептуально мы берем прошлую идею и накручиваем на нее бин. поиск по тому, на сколько мы должны подняться
-   Предварительно вычисляется таблица up[i][node], где up[i][node] — предок узла node на расстоянии 2<sup>i</sup>. Как такое считать?
    - up[0][v] = pv
    - up[k][v] = up[k-1][up[k-1][v]]
 -   Во время запроса LCA используются двоичные представления расстояний, чтобы быстро "поднимать" узлы.
 -   Общая идея та же, что и в подходе с уровнями, но с более быстрыми операциями подъема.  Этот метод отлично подходит для множества запросов LCA.

```cpp
// n - высота дерева
for k = log n...0:, n
    pu = up[k][u]
    if(!isParent(pu, v)):
        u = pu

```