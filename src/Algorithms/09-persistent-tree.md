# Персистентность

## Мотивация

Мы хотим откатываться в прошлые состояния.

## Виды персистентности

-  Частичная - можем изменять только последнюю версию, но читать любое прошлое состояние. Это компромисс между гибкостью и простотой реализации. Примеры: хранение истории изменений в текстовом редакторе, "undo/redo".

-  Полная - можем изменять любое прошлое состояние, при этом изменения создают новую версию, не влияя на исходное состояние. Это наиболее гибкий подход, позволяющий исследовать различные ветви развития данных. 

-  Конфлюентная - полная персистентность с возможностью объединять различные версии, порождая новые. Этот вид персистентности является наиболее сложным в реализации, но открывает интересные возможности для анализа и синтеза исторических данных. Похоже на ветки в системах контроля версий (Git).

## Учимся в персистентность

### Персистентный стек


Пусть у нас стек — это односвязный список.  В персистентной версии, каждый push создаёт новую ноду односвязного списка, разделяя часть структуры с предыдущими версиями.  Таким образом, у нас есть один большой-стек дерево, и масив "указателей" на вершины каждой из версий

Реализация операции push:

Операция push(value, stack) создает новый элемент (ноду) списка, в котором:

-  value - значение, которое кладется на стек.
-   next - указатель на предыдущую версию стека stack.

Положим в индекс текущей версии указатель на данную вершину. Таким образом,  push не изменяет предыдущую версию и никак не трогает другие версии.  Важно отметить, что push выполняется за O(1), так как создается только один новый элемент.

Реализация операции pop:

Операция pop(stack) возвращает новую версию стека, полученную путем удаления первого элемента из списка stack. Предыдущая версия stack остается неизменной.  pop также выполняется за O(1), так как просто возвращает указатель на следующий элемент в списке и ставит указатель в массиве версий на эту вершину

### Персистентная очередь

2 персистентных стека. Версия нашей очереди характеризуется версиями 2-ух стеков. Но проблема, когда перекладываем: делая push и pop к одной версии мы каждый раз будем тратить O(n) времени на перекладку. То есть мы проигрываем в асимптотике. (частичная персистентность бы тут прокатила)

Амортизированные оценки ломаются.


### Персистентный массив

#### Fat nodes

Каждый узел (node) структуры данных содержит историю изменений своих полей. Поиск нужной версии поля осуществляется по временной метке. Этот подход может потребовать значительного объема памяти для хранения истории.

В данном случае получилось, что мы реализовали частичную персистентность

Сдлеаем полностью персистентный массив, для этого научимс делать персистентное ДО

### Персистентное ДО

Умеем минимум на отрзке и изменять значение в точке.

Применим технику Path Coping.

